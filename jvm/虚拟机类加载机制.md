##虚拟机类加载机制
### 类加载的时机
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（verification[,vɛrɪfɪ'keʃən]）、准备（preparation）、解析（resolution[,rɛzə'luʃən]）、初始化（initialization[ɪ,nɪʃəlɪ'zeʃən]）、使用（using）和卸载（unloading）。

对于初始化阶段，虚拟机严格规定了只且只有5种情况必须立即对类进行“初始化”

1. 遇到new、getstatic、putstatic或者invokstatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的java场景是：使用new关键字实例化对象的时候、读取或者设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，已经调用一个类的静态方法的时候。
2. 使用java.lang.reflect [rɪ'flɛkt]包的方法对类进行反射调用的时候，如果类没有初始化过，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类。
5. 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

**除此之外，所有引用类的方式都不会触发初始化，称为被动引用**

1. 通过子类引用父类的静态字段，不会导致子类初始化。
2. 通过数组定义来引用类，不会触发此类的初始化。

	```
		public class NotInittializetion{
			public static void main(string[] args){
				SuperClass[] sca = new SuperClass[10];
			}
		}
	```
	**数组初始化的字节码指令是 newarray**
3. 常量在编译阶段会存入调用类的常量池，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

	```
		public class ConstClass{
			static{
				sout("ConstClass init !!!")
			}
			
			public static final String HELLOWORLD="hello world";
		}
		
		public class NotInittializetion{
			public static void main(string[] args){
				print(ConstClass. HELLOWORLD);
			}
		}
	```
	
	
**接口的加载过程与类加载的过程稍有不同：**

当一个类在初始化时，要求其父类全部初始化完成，但是一个接口在初始化时，并不要求其父接口全部完成初始化，只有真正使用到父接口的时候（如引用接口中的常量）才会初始化。

###类与类加载器
比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即时这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。
###双亲委派模型
从JAVA虚拟机的角度来讲，只存在两种不同的类加载器：

一种是启动类加载器（Bootstrap ClassLoader）,这个类加载器由C++实现，是虚拟机自身的一部分；

另一种就是所有其他的类加载器，这些类加载器都由java语言实现，独立于虚拟机的外部，并且全部继承自抽象类java.lang.ClassLoader.

1. 启动类加载器（Bootstrap ClassLoader）:放在<java_home>\lib目录的或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。
2. 扩展类加载器（Extension ClassLoader）:负责加载放在<java_home>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用拓展类加载器。
3. 应用程序类加载器（Application ClassLoader）：这个类加载器是classloader中的getSystemClassLoader()方法的返回值，所以一般也称他为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是默认的类加载器。

			【启动类加载器】
				
			【扩展类加载器】

			【应用程序加载器】

		【自定义类加载器】 【自定义类加载器】 
		
上图这种称为类加载器的双亲委派模型。

双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应该有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现而是都使用组合关系来服用父加载器的代码。

双亲委派模型的工作过程：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器，每一个层次的类加载器都是如此，因为所有的加载请求最终都应该传递到最顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求时，子类才会尝试自己去加载。

双亲委派模型的实现：
```
	protected synchronized Class<?> loadClass(String name,boolean resolve){
		//首先检查请求的类是否已经被加载过了
		Class c = findLoadedClass(name);
		if(c == null){
			try{
				if(parent != null){
					c = parent.loadClass(name,false);
				}else{
					c = findBootstrapClassOrNull(name);
				}
			}catch(ClassNotFoundException e){
				//如果父类加载器抛出ClassNotFoundException 说明父类加载器无法完成加载请求
			}
			
			if(c == null){
				//在父类加载器无法加载的时候，在调用本身的findClass方法进行类加载
				c = findClass(name);
			}
			return c;
		}
	
	}
```