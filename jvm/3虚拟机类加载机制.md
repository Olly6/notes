## 虚拟机类加载机制
### 类加载的时机
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（verification[,vɛrɪfɪ'keʃən]）、准备（preparation）、解析（resolution[,rɛzə'luʃən]）、初始化（initialization[ɪ,nɪʃəlɪ'zeʃən]）、使用（using）和卸载（unloading）。

对于初始化阶段，虚拟机严格规定了只且只有5种情况必须立即对类进行“初始化”

1. 遇到new、getstatic、putstatic或者invokstatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的java场景是：使用new关键字实例化对象的时候、读取或者设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，已经调用一个类的静态方法的时候。
2. 使用java.lang.reflect [rɪ'flɛkt]包的方法对类进行反射调用的时候，如果类没有初始化过，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个类。
5. 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

**除此之外，所有引用类的方式都不会触发初始化，称为被动引用**

1. 通过子类引用父类的静态字段，不会导致子类初始化。
2. 通过数组定义来引用类，不会触发此类的初始化。

	```
		public class NotInittializetion{
			public static void main(string[] args){
				SuperClass[] sca = new SuperClass[10];
			}
		}
	```
	**数组初始化的字节码指令是 newarray**
3. 常量在编译阶段会存入调用类的常量池，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

	```
		public class ConstClass{
			static{
				sout("ConstClass init !!!")
			}
			
			public static final String HELLOWORLD="hello world";
		}
		
		public class NotInittializetion{
			public static void main(string[] args){
				print(ConstClass. HELLOWORLD);
			}
		}
	```
	
	
**接口的加载过程与类加载的过程稍有不同：**

当一个类在初始化时，要求其父类全部初始化完成，但是一个接口在初始化时，并不要求其父接口全部完成初始化，只有真正使用到父接口的时候（如引用接口中的常量）才会初始化。


### 类与类加载器
比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即时这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。
### 双亲委派模型
从JAVA虚拟机的角度来讲，只存在两种不同的类加载器：

一种是启动类加载器（Bootstrap ClassLoader）,这个类加载器由C++实现，是虚拟机自身的一部分；

另一种就是所有其他的类加载器，这些类加载器都由java语言实现，独立于虚拟机的外部，并且全部继承自抽象类java.lang.ClassLoader.

1. 启动类加载器（Bootstrap ClassLoader）:放在<java_home>\lib目录的或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。
2. 扩展类加载器（Extension ClassLoader）:负责加载放在<java_home>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用拓展类加载器。
3. 应用程序类加载器（Application ClassLoader）：这个类加载器是classloader中的getSystemClassLoader()方法的返回值，所以一般也称他为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是默认的类加载器。

			【启动类加载器】
				
			【扩展类加载器】

			【应用程序加载器】

		【自定义类加载器】 【自定义类加载器】 
		
上图这种称为类加载器的双亲委派模型。

双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应该有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现而是都使用组合关系来复用父加载器的代码。

双亲委派模型的工作过程：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器，每一个层次的类加载器都是如此，因为所有的加载请求最终都应该传递到最顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求时，子类才会尝试自己去加载。

双亲委派模型的实现：

```
	protected synchronized Class<?> loadClass(String name,boolean resolve){
		//首先检查请求的类是否已经被加载过了
		Class c = findLoadedClass(name);
		if(c == null){
			try{
				if(parent != null){
					c = parent.loadClass(name,false);
				}else{
					c = findBootstrapClassOrNull(name);
				}
			}catch(ClassNotFoundException e){
				//如果父类加载器抛出ClassNotFoundException 说明父类加载器无法完成加载请求
			}
			
			if(c == null){
				//在父类加载器无法加载的时候，在调用本身的findClass方法进行类加载
				c = findClass(name);
			}
			return c;
		}
	}
```

## 虚拟机字节码执行引擎
在不同的虚拟机实现里面，执行引擎在执行java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过JIT产生本地代码执行），也有可能两者兼备。

### 运行时栈帧结构
栈帧（stack frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。

### 局部变量表
局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。

局部变量表的容量以变量槽（variable slot ['vɛrɪəbl] [slɑt]）为最小单位。
一个slot可以存放一个32位以内的数据结构类型。java中占用32位的数据类型有 boolean 、byte、char、short、int、float、reference和returnAddress 8种类型。

对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的slot空间。在java中64位的数据类型只有long double。

**值得一提的是，这里把long和double数据类型分割存储的做法与“long和double的非原子性协定”中把一次long和double数据类型读写的做法有些类似。不过由于局部变量表是建立在线程的堆栈上，是线程私有的，无论读写两个连续的slot是否为原子操作，都不会引起数据的安全问题。**

在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static的方法），那局部变量表中第0位索引的slot默认是用于传递方法所属的对象实例的引用，在方法中可以通过关键字this来访问到这个隐含的参数。其他的参数则按照参数表顺序排列，占用从1开始的局部变量slot。

**为了节省栈帧空间，局部变量表中的slot是可以重用的，方法体重定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那么整个变量对应的slot就可以交给其他变量使用**

看一下局部变量表slot对垃圾收集的影响

代码1

```
public static void main(String[] args){
	byte[] placeholoder = new byte[64 * 1024 * 1024];
}
System.gc();

```
代码2

```
public static void main(String[] args){
	byte[] placeholoder = new byte[64 * 1024 * 1024];
}
int a = 0;
System.gc();

```
上面**代码1**中 64M的内存没有被回收，**代码2**中的被顺利回收。

根本原因是：局部变量变中的slot中是否还存有关于placeholoder数组对象的引用，第一次修改中，代码虽然已经离开了placeholoder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholoder原本所占用的slot还没有被其他变量所复用，所以作为GC Roots一部分的局部变量变依然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都很轻微。但如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null，这种操作可以作为在一种极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法次数达不到JIT的编译条件）下的奇技来使用。**不使用的对象应手动赋值为null**不过没有必要把这个当做一个普遍的编码规则来推广。原因有**两点**：从编码角度讲，以恰当的的变量作用域来控制变量回收时间才是最优雅的解决方法。第二点是在赋值null的操作在经过JIT编译优化后就会被消除掉，这时候将变量设为null是无意义的。

**类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另一次在初始化阶段，赋予程序员定义的初始值。因此，即时在初始化阶段没有为类变量赋值也没关系，类变量仍然有一个初始值。但是局部变量就不一样了，如果一个局部变量定义了但是没有赋初始值是不能使用的。**

### 操作数栈
操作数栈（operand stack）也常称作操作栈，它是一个后入先出栈。操作数栈的每一个元素可以是任意的java数据类型，包括long和double。32位数据类型所占的栈容量是1，64位的是2.

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是入栈出栈操作。java虚拟机的解释执行引擎称为”基于栈的执行引擎“，其中所指的栈就是操作数栈。

### 动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

我们知道Class文件的常量池中有大量的符号引用，这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用。另外一部分将会在每一次运行期间转化为直接引用，这部分称为动态连接。

### 方法返回值
当一个方法开始执行后，只有两种方式可以退出这个方法。第一种是执行引擎遇到任何一个方法返回的字节码指令。另一种退出方式是，在方法的执行过程中遇到了异常，并且这个异常没有在方法体内得到处理。

## 方法调用
方法调用并不等同于方法执行，方法调用唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。Class文件的编译过程中不包含传统编译中的链接步骤，一切方法调用在Class文件里面存储的都是符号引用而不是直接引用。所以需要再类加载期间，甚至到运行期才能确定方法的直接引用。
### 解析
所有方法调用中的目标方法在Class文件里都是一个常量池中的符号引用，在类加载阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是》方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。这类方法的调用称为解析。

静态方法和私有方法无法通过继承或者别的方法重写其他版本，因为都适合在类加载阶段进行解析。

**非虚方法：** 静态方法、私有方法、实例构造器、父类方法4类，它们在类加载的时候就会把符号引用转化为直接引用。

**虚方法：** 除去非虚方法（final方法除外）都是虚方法。

因为被final修饰的方法无法被覆盖，没有其他版本，所以多态选择的结果肯定是唯一的。java语言中明确规定了final方法是一种非虚方法。

解析调用是一个静态的过程，在编译阶段就完全确定，在类装载的解析阶段就可以把涉及到的符号引用转化为直接引用，不会延迟到运行期再去完成。

### 分派
java具备面向对象的3个基本特征：封装、继承和多态。分派就是多态的最基本的体现。

#### 静态分派

```
public class StaticDispatch {
	static abstract class Human{
	}
	static class Man extends Human{
	}
	static class Woman extends Human{
	}
	public static void sayHello(Human guy){
		System.out.println("hello,guy!");
	}
	public static void sayHello(Man guy){
		System.out.println("hello,gentlemen!");
	}
	public static void sayHello(Woman guy){
		System.out.println("hello,lady!");
	}
	
	public static void main(String[] args) {
		Human man=new Man();
		Human woman=new Woman();
		sayHello(man);
		sayHello(woman);
	}
}

运行结果
hello,guy!
hello,guy!

```
Human man=new Man();

Human被称为变量的静态类型（static type），后面的Man则称为变量的实际类型，静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果是运行期间才可以确定，编译器并不是到一个对象的实际类型是什么。

```
//静态类型变化
Human man=new Man();
Human woman=new Woman();

//实际类型变化
sayHello(（Man）man);
sayHello(（Woman）man);

```

重载是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的，因为在编译阶段，javac编译器会根据参数的静态类型来决定使用哪个版本。

所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。

#### 动态分派
动态分派和重写（override）有很密切的关系。

```
public class DynamicDispatch {
	static abstract class Human{
		protected abstract void sayHello();
	}
	static class Man extends Human{ 
		@Override
		protected void sayHello() { 
			System.out.println("man say hello!");
		}
	}
	static class Woman extends Human{ 
		@Override
		protected void sayHello() { 
			System.out.println("woman say hello!");
		}
	} 
	public static void main(String[] args) {
		
		Human man=new Man();
		Human woman=new Woman();
		man.sayHello();
		woman.sayHello();
		man=new Woman();
		man.sayHello(); 
	}
}

运行结果：
man say hello!
woman say hello!
woman say hello!

```

上面的代码展示了同样都是Human的两个变量调用sayHello方法执行了不同的行为。

虚方法是用的invokvirtual [ˈvɝ​tʃʊəl]指令

invokvirtual的运行时解析大致分为以下几步：

1. 找到操作数栈顶的第一个元素所指向的对象的**实际类型**，记做C
2. 找到C和常量中的描述符和简单名称都相符的方法，然后进行访问权限验证，通过返回直接引用，不通过
3. 否则，则按照继承关系从下往上一次对C的各个父类进行第2步的搜索和验证过程。
4. 还找不到抛出异常

由于invokevirtual执行的第一步就是在运行期间确定接受者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是java的方法重写的本质。

### 虚方法表
动态分派是非常频繁的动作，并且动态分派的方法版本选择过程需要再运行时在类的方法元数据中搜索合适的目标方法。为了提高性能，就在方法区中简历一个虚方法表，于此对应的在invokeinterface执行时也会用到接口方法表。使用虚方法表索引来代替元数据查找以提高性能。

虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口，如果子类重写了这个方法，子类方法表中的地址会替换成指向子类的入口。

**如果子类并没有重写父类的方法，在编译的时候，在子类也会有父类那个方法的字节码**

## 语法糖
### 泛型与类型擦除
List<int>与List<String>是不同的数据类型
有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。

java中的泛型则不一样，它只在程序员源代码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型，并且在相应的地方插入了强制转型代码。因此，对于运行期的java语言，ArraylIST<int>和ArraylIST<String>就是同一个类，java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。

### 自动装箱、拆箱与遍历循环
包装类的”==“运算在不遇到算术运算符的情况下不会自动拆箱 以及他们的equals()方法不会进行自动转型。

## JIT
JAVA程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或者代码块的运行特别频繁，就会把这些代码认定是**热点代码**，为了提高热点代码的运行效率，在运行时，虚拟机会把这些代码编译成本地平台相关的机器码，并进行各种层次的优化，完成这个认为的编译器称为即时编译器（just in time compiler JIT）
 

### 逃逸分析
逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能会被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。

如果能证明一个对象不会逃逸到方法或者线程之外，也就是别的方法或线程无法通过任何途径访问这个对象，则可能为这个变量进行一些高效的优化：

1. 栈上分配：如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很好的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。
2. 同步消除：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉。
3. 标量替换：标量是指一个数据已经无法再分解成更小的数据来表示了，java虚拟机种的原始数据类型都不能再进一步分解，他们就称为标量。相对的，如果一个数据可以继续分解，那么就称为聚合量。java中的对象就是经典的聚合量。如果把一个java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问的话就叫标量替换。
