## Java内存模型与线程
### Java内存模型
Java内存模型（Java Memory Model，JMM）是用来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机种将变量存储到内存和从内存中取出变量这样的细节。此处的变量（Variables）与java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享所以自然不会存在竞争问题。

JMM规定了所有的变量都存储在主内存（main memory）中，每条线程还有自己的工作内存（working memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间变量值的出传递均需要通过主内存来完成。

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之间的时间细节，JMM定义了以下8种操作来完成。虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量，例外）

1. lock（锁定）：作用于主内存，把一个变量标识为一条线程独占
2. unlock（解锁）：作用于主内存，把一个处于锁定状态的变量释放，释放后的变量才可以被其他线程锁定。
3. read（读取）：作用于主内存，把一个变量的值从主内存传输到工作内存，以便后续的load使用
4. load（载入）：作用于工作内存，它把read操作从主内存得到的变量值放入工作内存的副本中
5. use（使用）：作用于工作内存的变量，他把工作内存中的一个变量传递给执行引擎。
6. assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存中的变量。
7. store（存储）：作用于工作内存，它把工作内存中的一个变量的值传送到主内存。
8. write（写入）：作用于主内存，它把store操作从工作内存中得到的变量放到主内存。

**如果要把一个变量从主内存复制到工作内存，那就要顺序的执行read和load，如果把变量从工作内存同步回主内存，就要顺序的执行store和write。JMM只要求上述两个操作必须按顺序执行，而没有保证是连续执行，也就是说中间可以插入其他指令。**

### volatile
当一个变量定义为volatile之后，它将具备两种特性：

一. 保证次变量对所有线程的可见性，也就是说当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普遍的变量的值在线程间传递均需要通过主内存来完成。
**由于volatile变量只能保证可见性，在不符合以下规则的运算场景中，仍然需要加锁来保证原子性**

1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程能修改变量的值。
2. 变量不需要与其他的状态变量共同参与不变约束。

二、禁止指令重排

普通的变量仅仅会保证在改方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不不能变量赋值操作的顺序与代码中的执行顺序一致。这也是JMM中所谓的**线程内表现为串行的语义（withinThread As-If-Serial Semantics）**

在于有volatile修饰的变量，赋值后会多执行一个“lock”指令，这个操作相当于一个内存屏障（memory Barrier），只有一个CPU访问内存时，并不需要内存屏障，但如果有多个CPU访问同一内存，且其中有一个在观测另一个就需要内存屏障来保证一致性。

**指令重排**是CPU采用了允许将多条指令不按程序规定的顺序分开发送给相应电路单元处理。但并不是说指令任意重排，CPU只需要能正确处理指令依赖情况以保证程序能得出正确的执行结果。

### **除了volatile之外，java还有两个关键字能实现可见性，synchronized和final。synchronized的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）”这条规则获得的。**

### **final : 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this的引用传递出去，那在其他线程中就能看到final字段的值。**


### 先行发生原则（happens-before）
这个原则很重要，它是判断数据是否存在竞争、线程是否安全的主要依据

1. 程序次序规则（program order rule）：在一个线程内，安装程序代码顺序，书写在前面的操作先行发生于书写在后面的操作，准确的说是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
2. 管程锁定规则（monitor Lock rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，后面是指时间上的先后顺序。
3. volatile变量规则（volatile variable rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面也是指时间上的先后顺序。
4. 线程启动规则（thread start rule）：thread对象的start方法先行发生于此线程的每一个动作
5. 线程终止规则（thread termination rule）：线程的所有操作都先发生于对此线程的终止检测，我们可以通过thread.join()方法结束、thread.isAlive()的返回值等手段检测到线程已经终止执行。
6. 线程中断规则（thread interruption）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
7. 对象终结规则（finalizer rule）:一个对象的初始化完成（构造函数执行完毕）先行发生于他的finalize()方法的开始。
8. 传递性（transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那么可以得出操作A先行发生于操作C。

**上面是java语言中无需任何同步手段保障就能成立的先行发生原则**

**时间先后顺序与先行发生原则之间基本没有太大的关系** 
 
