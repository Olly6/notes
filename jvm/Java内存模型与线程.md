## Java内存模型与线程
### Java内存模型
Java内存模型（Java Memory Model，JMM）是用来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机种将变量存储到内存和从内存中取出变量这样的细节。此处的变量（Variables）与java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享所以自然不会存在竞争问题。

JMM规定了所有的变量都存储在主内存（main memory）中，每条线程还有自己的工作内存（working memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间变量值的出传递均需要通过主内存来完成。

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之间的时间细节，JMM定义了以下8种操作来完成。虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量，例外）

1. lock（锁定）：作用于主内存，把一个变量标识为一条线程独占
2. unlock（解锁）：作用于主内存，把一个处于锁定状态的变量释放，释放后的变量才可以被其他线程锁定。
3. read（读取）：作用于主内存，把一个变量的值从主内存传输到工作内存，以便后续的load使用
4. load（载入）：作用于工作内存，它把read操作从主内存得到的变量值放入工作内存的副本中
5. use（使用）：作用于工作内存的变量，他把工作内存中的一个变量传递给执行引擎。
6. assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存中的变量。
7. store（存储）：作用于工作内存，它把工作内存中的一个变量的值传送到主内存。
8. write（写入）：作用于主内存，它把store操作从工作内存中得到的变量放到主内存。

**如果要把一个变量从主内存复制到工作内存，那就要顺序的执行read和load，如果把变量从工作内存同步回主内存，就要顺序的执行store和write。JMM只要求上述两个操作必须按顺序执行，而没有保证是连续执行，也就是说中间可以插入其他指令。**

### volatile
当一个变量定义为volatile之后，它将具备两种特性：

一. 保证次变量对所有线程的可见性，也就是说当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普遍的变量的值在线程间传递均需要通过主内存来完成。
**由于volatile变量只能保证可见性，在不符合以下规则的运算场景中，仍然需要加锁来保证原子性**

1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程能修改变量的值。
2. 变量不需要与其他的状态变量共同参与不变约束。

二、禁止指令重排

普通的变量仅仅会保证在改方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不不能变量赋值操作的顺序与代码中的执行顺序一致。这也是JMM中所谓的**线程内表现为串行的语义（withinThread As-If-Serial Semantics）**

在于有volatile修饰的变量，赋值后会多执行一个“lock”指令，这个操作相当于一个内存屏障（memory Barrier），只有一个CPU访问内存时，并不需要内存屏障，但如果有多个CPU访问同一内存，且其中有一个在观测另一个就需要内存屏障来保证一致性。

**指令重排**是CPU采用了允许将多条指令不按程序规定的顺序分开发送给相应电路单元处理。但并不是说指令任意重排，CPU只需要能正确处理指令依赖情况以保证程序能得出正确的执行结果。

### **除了volatile之外，java还有两个关键字能实现可见性，synchronized和final。synchronized的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store和write操作）”这条规则获得的。**

### **final : 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this的引用传递出去，那在其他线程中就能看到final字段的值。**


### 先行发生原则（happens-before）
这个原则很重要，它是判断数据是否存在竞争、线程是否安全的主要依据

1. 程序次序规则（program order rule）：在一个线程内，安装程序代码顺序，书写在前面的操作先行发生于书写在后面的操作，准确的说是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
2. 管程锁定规则（monitor Lock rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，后面是指时间上的先后顺序。
3. volatile变量规则（volatile variable rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的后面也是指时间上的先后顺序。
4. 线程启动规则（thread start rule）：thread对象的start方法先行发生于此线程的每一个动作
5. 线程终止规则（thread termination rule）：线程的所有操作都先发生于对此线程的终止检测，我们可以通过thread.join()方法结束、thread.isAlive()的返回值等手段检测到线程已经终止执行。
6. 线程中断规则（thread interruption）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
7. 对象终结规则（finalizer rule）:一个对象的初始化完成（构造函数执行完毕）先行发生于他的finalize()方法的开始。
8. 传递性（transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那么可以得出操作A先行发生于操作C。

**上面是java语言中无需任何同步手段保障就能成立的先行发生原则**

**时间先后顺序与先行发生原则之间基本没有太大的关系** 
 
##java线程
对于sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型来实现的，一条java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模型就是一对一的。

### 状态转换
java语言定义了5种进程状态，在任意一个时间点中，一个进程只能有且只有其中的一个状态，这5种状态分别是：

1. 新建（New）：创建后尚未启动的线程处于这种状态。
2. 运行（runable）：runable包括了操作系统线程状态中的running和ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。
3. 无限期等待（waiting）：处于这种状态的检查不会被分配CPU执行时间，他们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限等待状态：

* 没有设置timeout参数的Object.wait()方法。
* 没有设置timeout参数的Thread.join()方法。
* LockSupport.park()方法。

4. 限期等待（timed waiting）：处于这种状态的进程也不会被分配CPU执行时间，不过无须等待被其他线程显式的唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：

* Thread.sleep()方法
* 设置了Timeout参数的Object.wait()方法
* 设置了timeout参数的Thread.join()方法。
* LockSupport.parkNanos()方法。
* LockSupport.parkUntil()方法。

5. 阻塞（Blocked）:进程被阻塞了。**“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待获取到一个排它锁，这个事件在另一个线程放弃这个锁的时候发生。而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态**

### 线程安全
当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者调用方进行任何其他的协调操作，调用这个对象的行为都可以获得**正确的结果**，那这个对象就是线程安全的。

**note：这个定义比较拗口，后续要改。**

按照线程安全的“安全程度”由强支弱来排序，我们可以将java语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

1. 不可变

不可变(Immutable)的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何的线程安全保障措施。在讲final的时候说过，只要一个不可变的对象被正确的构建出来（没有发生this引用逃逸）那其外部的可见状态也永远不会改变。

**java中如果共享数据是一个基本数据类型，那么只要在定义时使用final修饰就可以保证它是不可变的。如果共享数据是一个对象，那么就需要保证对象的行为不会对其状态产生任何影响。例如String，它是一个典型的不可变对象，调用substring() replace() concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。**

保证对象行为不影响自己状态的途径很多种，最简单的就是把对象中带有状态的变量都声明为final，这样在构造函数结束之后，它就是不可变的。

*java中除了String外，还有枚举类型，Number的部分子类如Long和Double等数值包装类型，BigInteger BigDecimal等大数据类型但是同为Number的子类型的原子类AtomicInteger和AtomicLong则并非不可变的。*

2. 绝对线程安全 ，可以看看Vector是一个线程安全的容器，方法都是被synchronized修饰的。当然也不是绝对安全
3. 相对线程安全：相对的线程安全就是通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要再调用端使用额外的同步手段来保证调用的正确性。**java中大部分的线程安全类都属于这种类型，例如Vector hashtable Collections的synchronizedCollection()方法包装的集合**

4. 线程兼容：线程兼容是指对象本身不是线程安全的，但是可以通过在调用端正确的使用同步手段来保证对象在并发环境中安全使用。java中的大部分类都是线程兼容的，如前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。
5. 线程对立：是指不管调用端是否采用了同步措施，都无法再多线程环境中并发使用的代码。

一个线程对立的例子是Thread类的suspend()和resume()，如果有两个线程同时持有一个线程对象，一个去尝试中断，一个尝试去恢复，如果并发进行的话，无论调用是否进行了同步，目标线程都是存在死锁风险的，如果suspend()中断的线程就是即将要执行的resume()的那个线程，肯定要死锁了。

### 线程安全的实现方法
####1. 互斥同步（悲观锁）

互斥同步是最常见的一种并发正确性保障手段，同步是指在多个线程并发访问共享数据时，保障共享数据在同一个时刻只被一条线程使用。

java里最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后，会再同块的前后分别形成monitorenter和monitorexit这两个字节码指令，**这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。如果java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，就是根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或者Class对象来作为锁对象**

在执行monitorenter指令时，首先要去尝试获取对象的锁，如果这个对象没有被锁，或者当前线程已经拥有了该对象的锁，把锁的计数器+1，相应的，在执行monitorexit指令时会将锁计数器-1，当计数器为0时，锁就被释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，只要对象锁被另一个线程释放为止。

**需要注意的是：首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的情况。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。** 

除了synchronized之外，还可以使用重入锁(ReentrantLock)来实现同步，在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁（lock()和unlock()方法配合try/finally语句块来完成），一个表现为远程语法层面的互斥锁。不过Reentranlock比synchronized多了一些高级特性。

####2. 非阻塞同步（乐观锁）

通俗的说就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施（最常见的就是不断的重试，直到成功为止。CAS）.

##### ABA问题

一个变量初始的时候是A，后来改成B，又改回A，而CAS操作就误认为它从来没有被改变过。这就是ABA问题。为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它通过控制变量值的版本来保证CAS的正确性。这个方案比较鸡肋，因为大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。

####3. 无同步方案
	
要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那就无需任何同步措施来保证正确性。

**可重入代码：** 有一些共同的特征，例如不依赖存储在堆上的数据和公共的资源、用到的状态量都是由参数中传入、不调用非可重入的方法等。可以通过一个简单的原则来判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那么它就满足可重入性的要求，当然也就是线程安全的。

**线程本地存储(Thread local storage)：**如果可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

每个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。


