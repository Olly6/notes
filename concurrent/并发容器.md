无论在直接迭代还是在java5引入的for-each循环语法中，对容器类进行迭代的标准方式都是使用Iterator。然而，如果有其他线程并发的修改容器，那么即使是使用迭代器也无法避免在迭代期间对容器加锁。在设计同步容器类的迭代器时没有考虑到并发修改的问题，且他们表现出的行为是"fail-fast"快速失败。

如果不希望在迭代期间对容器加锁，那么一种替代方法就是“克隆”容器，并在副本上进行迭代。由于副本被封闭在线程内，因此其他线程不会再迭代期间对其进行修改，这样就避免了抛出ConcurrentModificationException(在克隆过程中仍然需要对容器加锁)。在克隆容器时存在显著的性能开销。这种方式的好坏取决于多个因素，包括容器的大小，在每个元素上执行的工作，迭代操作相对于容器其他操作的调用频率，以及在响应时间和吞吐量等方面的需求。

容器的hashCode和equals等方法也会间接的执行迭代操作，当容器作为另一个容器的元素或者键值时，就会出现这种情况。同样，containsAll,removeAll,retainAll等方法，已经把容器作为参数的构造函数，都会对容器进行迭代。所有这些间接的迭代操作都可能抛出ConcurrentModificationException.

### 并发容器
#### 1.ConcurrentHashMap
同步容器在执行每个操作期间都持有一个锁。在一些操作中，例如HashMap.get或者List.contains,可能包含大量的工作：当遍历散列桶或链表来查找某个特定的对象时，必须在许多元素上调用equals.在基于散列的容器中，如果hashCode不能很均匀的分布散列值，那么容器中的元素就不会均匀的分布在整个容器中。某些情况下，某个槽糕的散列函数还会把一个散列表变成线性链表。当遍历很长的链表并且在某些或者全部元素上调用equals方法时，会花费很长的时间，而其他线程在这段时间内都不能访问该容器。

与HashMap一样，ConcurrentHashMap也是一个基于散列的Map，但它提供了一种完全不同的加锁策略来提供更高的并发性和伸缩性。ConcurrentHashMap并不是将每个方法都在同一个锁上同步并使得每次只有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更大程度的共享，这种机制称为分段锁(Lock striping)。在这种机制中，任意数量的读取线程可以并发的访问map，执行读取操作的线程和执行写入操作的线程可以并发的访问map，并且一定数量的写入线程可以并发的修改map。ConcurrentHashMap带来的结果是，在并发访问环境下降实现更高的吞吐量，而在单线程环境中只损失非常小的性能。

ConcurrentHashMap与其他并发容器一起增强了同步容器类：

* 1.他们提供的迭代器不会抛出ConcurrentModificationException,因此不需要在迭代过程中对容器加锁。
* 2. ConcurrentHashMap返回的迭代器具有弱一致性（Weakly Consistent）而并且快速失败。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以在迭代器被构造后修改操作反映给容器。

在ConcurrentHashMap中没有实现对Map加锁以提供独占访问。在HashTable和SynchronizedMap中，获得map的锁能防止其他线程访问这个map。在一些不常见的情况中需要这个功能，例如，通过原子方式添加一些映射，或者对map迭代若干次并在此期间保持元素顺序相同。

由于ConcurrentHashMap不能被加锁来执行独占访问，因此我们无法使用客户端加锁来创建新的原子操作。一些常见的复合操作，例如，"若没有则添加"、“若相等则移除”、“若相等则替换”等，都已经实现为原子操作并且在ConcurrentMap的接口中声明、这种情况下可以考虑ConcurrentMap。


#### 2.CopyOnWriteArrayList
CopyOnWriteArrayList用于替代同步list，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。

“写入时复制（Copy-on-write）”容器的线程安全性在于，只要正确的发布一个事实不可变的对象，那么在访问该对象时就不再需要进一步的思考。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变现。

写入时复制容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对其进行同步时，只需确保数组内容的可变性。因此多个线程可以同时对这个容器进行迭代，而不会彼此干扰或者与修改容器的线程互相干扰。

写入时复制容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素与迭代器创建时的元素完全一致，而不必考虑之后修改操作带来的影响。

显然，每当修改容器时都会复制底层数组，这需要一定的开销，特别是当容器的规模较大时。仅当迭代操作远远多于修改操作时，才应该使用“写入复制”容器。

**疑问：指向底层基础数组的引用  这个底层基础数组是指的什么？？？？**

#### 3阻塞队列和生产者-消费者模式
阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。如果队列已经满了，那么put方法将阻塞直到有空间可用。如果队列为空，take方法将会阻塞直到有元素可用。队列可以是有界的也可以是无界的，无界队列永远都不会满，因此无界队列上的put方法也永远不会阻塞。

在基于阻塞队列构建的生产者-消费者设计中，当数据生成时，生产者把数据放入队列，而当消费者准备处理数据时，将从队列中获取数据。生产者不需要知道消费者的标识或数量，或许他们是否是唯一的生产者，而只将数据放入队列即可。同样，消费者也不需要知道生产者是谁，或者工作来此何处。BlockingQueue简化了生产者-消费者设计的实现过程，他支持任意数量的生产者和消费者。一种最常见的生产者-消费者模式就是线程池与工作队列的组合，在Executor  [ɪg'zɛkjətɚ]任何执行框架就提现了这种模式。