## 线程安全性
要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的(Shared)和可变的(Mutable)状态的访问。

非正式意义上来说，对象的状态是指存储在状态变量(例如实例或者静态域)中的数据。对象的状态可能包括其他依赖对象的域。

**共享** 意味着变量可以由多个线程同时访问。而**可变**则意味着变量的值在其生命周期内可以发生变化。

要使得对象是线程安全的，需要采用同步机制来协同对对象可变状态的访问。

当多个线程访问某个状态变量并且其中有一个线程执行写操作时，必须采用同步机制来协同这些线程对变量的访问。java中的主要同步机制是关键字synchroized，它提供了一种独占的加锁方式，但“同步”这个术语还包括voliatile类型的变量，显示锁以及原子变量。

如果多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：

* 不在线程之间共享该状态的变量
* 将状态变量修饰为不可变的变量
* 在访问状态变量时候使用同步

### 什么是线程安全性？
在线程安全性的定义中，最核心的概念就是**正确性**。

当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。

*当多个线程访问某类时，不管运行时环境采用任何调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么久称这个类是线程安全的。*

#### 1、无状态的对象一定是线程安全的
大部分的Servlet就是无状态的：它既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量表中，并且只能由正在执行的线程访问。

#### 2、原子性
例如 ++count是一种紧凑的语法，使其看上去只是一个操作，但这个操作并非原子性的。实际上，它包含了三个独立的操作：读取count值，将值+1，然后将计算结果写入count。这是一个“读取-修改-写入”的操作序列，并且其结果状态依赖于之前的状态。

* #####竞态条件

	当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。最常见的的竞态条件类型就是“先检查后执行(Check-Then-Act)”操作：即通过个一个可能失效的观测结果来决定下一步的动作。上面的++count就是这种情况。

* #####延迟初始化中的竞态条件

	使用“先检查后执行”的一种常见情况就是延迟初始化。延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时确保志被初始化一次。
	
	```
	public class LazyInitRace{
			private ExpensiveObject instance = null;
			
			public ExpensiveObject getInstance(){
				if(instance = null){
					instance = new ExpensiveObject();
				}
				return instance;
			}
		}
	```
	
	
	上面代码中包含了一个竞态条件，它可能会破坏这个类的正确性。假定线程A和线程B同时执行getInstance。A看到instance为空，因而创建一个新的ExpensiveObject实例。B同样需要判断instance是否为空，要取决于不可预测的时序，包括线程的调度方式，以及A需要花多长时间来初始化ExpensiveObject并设置instance。如果当B检测时，instance为空，那么在两次调用getInstance时可能会得到不同的结果，即时getInstance通常被认为是返回相同的实例。
	
	在上面的++count操作中存在另一种竞态条件。在“读取-修改-写入”这种操作中，基于对象之前的状态来定义对象状态的转换。要递增一个计数器，必须要知道它之前的值，并确保在执行更新的过程中没有其他线程会修改或使用这个值。
	
* #####复合操作

	要避免竞态条件，就要包含一组以原子方式执行的操作。在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或者之后读取和修改状态，而不是在修改状态的过程中。
	
	*假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说都是原子的。原子操作是指，对于访问同一个状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。*
	
	为了确保线程安全性，**先检查后执行（例如延迟初始化）**和**读取-修改-写入（例如递增运算）** 等操作都必须是原子的。这两种操作称为**复合操作**。对复合操作加锁是确保原子性的内置机制。
	
	**++Count可以用原子类替换，这样也是线程安全的 AtomicLong 等**
	
#### 3、加锁机制

* #####内置锁
	
	java提供了一种内置的锁来支持原子性：同步块代码(Synchronized Block)。同步块代码分为两部分：一个是作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码的锁就是方法调用所在的对象。静态的synchronized方法以Class对象为锁。
	
	内置锁又叫互斥锁，这就意味着最多只有一个线程能持有这种锁。当线程A尝试获取一个由线程B持有的锁时，线程A必须必须等待或者阻塞，直到线程B释放这个锁。如果B不释放这个锁，那么A就要永远等待下去。
* #####重入

	当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因为如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。**重入**意味着获取锁的操作粒度是**线程**而不是**调用**。
	
	重入的一种实现方式就是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0，这个锁就认为是没有被任何线程持有。当一个线程请求一个未被持有的锁时，JVM会记下锁的持有者，并且将获取计数值为1，如果同一个线程再次获取这个锁，计数值递增，而当线程退出同步代码块时，计数器会相应的递减。当计数器为0时，这个锁将被释放。
	
	```
	public class Widget {
		public synchronized void doSth(){
			....
		}
	}
	
	public class LoggingWidget extends Widget {
		public synchronized void doSth(){
			super.doSth();
		}
	}
	
	```
	上述代码，子类改写了父类的synchronized方法，然后调用父类中的方法，此时如果没有可重入的锁，那么这段代码将会发生死锁。由于Widget和LoggingWidget种doSth方法都是synchronized方法，因此每个doSth方法在执行前都会获取Widget上的锁，因为这个锁因为这个锁已经被持有，从而线程将永远停顿下去，等待一个永远也无法获得的锁。重入则避免了这种死锁情况的发生。
	
#### 4、用锁来保护状态
由于锁能使其保护的diamante路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。只要始终遵循这些协议，就能保证状态的一致性。

复合操作通过执行过程中持有一个锁来保证原子性，然而紧紧将符合操作封装到一个同步块中是不够的。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。

**对于可能被多个线程同时访问的可变状态变量，在访问他们时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。**

**每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员指导是哪一个锁**

一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变变量的代码路径进行同步，是的在该对象不会发生并发访问。

并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。

当某个变量由锁来保护时，意味着在每次访问这个变量时都需要首先获得锁，这样就确保在同一时刻只有一个线程可以访问这个变量。当类的不变性条件涉及多个状态量时，那么还有另外一个需求：**在不变性条件中的每个变量都必须由同一个锁来保护，因此可以在单个原子操作中访问或更新这些变量，从而确保不变性条件不会破坏。**

**对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护**

**虽然synchronized方法可以确保单个操作的原子性，但是如果要把多个操作合并为一个复合操作，还是需要额外的加锁机制。此外，将每个方法都作为同步方法还可能导致活跃性问题或性能问题。？？？？？为啥呢？？synchronized同步块不是可以把复合操作变为原子操作么?为啥还需要额外的加锁？难道是因为两个操作是互相独立的 比如一个是插入 一个是更新？**


## 对象的共享
常见的错误是，认为关键字synchronized只能用于实现原子性或者确定"临界区(Critical Section)"。同步还有另一个重要的方面：内存可见性(Memroy Visibility)。我们不仅仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。

为了确保多个线程之间对内存写入操作的可见性，必须使用同步。
### 1.可见性
JMM要求变量的读取和写入操作操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读写操作分为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读写在不同的线程，那么很可能会读取到某个值的高32位和另一个值的低32位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明他们，或者用锁保护起来。

加锁的含义不仅仅是局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

#### volatile变量

java里提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因为不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

volatile变量对可见性的影响比volatile变量本身更重要。从内存可见性的角度来看，写入volatile变量相当于退出同步代码块，而读取volatile变量就相当于进入同步代码块。不建议过度依赖volatile变量提供的可见性。如果在代码中依赖volatile变量来控制状态的可见性，通常比使用锁的代码更脆弱，也更难以理解。

虽然volatile变量很方便，但是也有一些局限性。volatile变量通常是做某个操作完成、发生中断或者状态的标志。

**加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。**

当且仅当满足以下所有条件时，才应该使用volatile变量：

1. 对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。
2. 该变量不会与其他状态变量一起纳入不变性条件中
3. 在访问变量时不需要加锁。

#### 发布与逃逸
发布（publish）一个对象的意思是指，使对象能够在当前作用域之外的代码中使用。例如，将一个指向该对象的引用保存到其他代码可以访问的地方，或者在一个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。在许多情况下，我们要确保对象及其内部状态不被发布。而在某些情况下，我们又需要发布某个对象，但如果在发布时需要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。

当某个不该发布的对象被发布时，这种情况就叫逃逸（escape）

**数据states已经逃逸出了它所在的作用域，任何调用者都可以修改这个数据的内容。**

```
class UnsafeSatates {
	privaet String[] states = new String[]{"AK","AL"};
	
	public String[] getStates(){retrun states;}
}
```

**阴式的使this引用逃逸，在这个内部类实例中包含了对ThisEscape实例的隐含调用**

```
public class ThisEscape{
	public ThisEscape(EventSource source){
		source.registerListener(
			new EventListener(){
				public void onEvent(Event e){
					doSth(e);
				}
			}
		)
	}
}
```

**安全的对象构造过程，不要再构造过程中this逃逸**

当对象在其构造函数中创建一个线程时，无论是显式(通过将传给构造函数)还是隐式(由于Thread或者runnable是该对象的一个内部类)创建，this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见他。在构造函数中创建线程并没有错误，但是最好不要立即启动他，而是通过一个star或者initialize方法启动。

在构造函数中调用一个可改写的实例方法时(既不是私有方法，也不是final方法)同样会导致this引用在构造过程中逃逸。

#### 3、线程封闭
当访问共享的可变数据时，通常需要使用同步。一个避免使用同步的方式就是不同享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭，它是实现线程安全的最简单方式之一。当某个对象封闭在一个线程中，这个方法将自动实现线程安全性，及时被封闭的对象本身不是线程安全的。

例如JDBC里的Connection对象。JDBC并不要求Connection对象必须是线程安全的。当然JDBC线程池是线程安全的。非线程安全的线程池是毫无意义的。

* ##### 栈封闭

	栈封闭是线程封闭的一种特例。在栈封闭中，只能通过局部变量才能访问对象，因为是线程私有的。
	
	对于基本类型的局部变量，无论如何都不会破坏栈封闭性。
	
	对于对象引用的栈封闭性，需要多做一些工作。
* #### ThreadLocal类
	
	维持线程封闭的一种更规范的方法就是使用ThreadLocal，这个类提供了get与set等接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。
	
### 4、不变性
如果某个对象在被创建后其状态就不能被修改，那么这个对象就是不可变对象。线程安全性是不可变对象的固有属性之一，他们的不可变性是由构造函数创建的，只要他们的状态不改变，那么这些不变性条件就能得以维持。

**不可变对象一定是线程安全的**

当满足一下条件时，对象才是不可变的：

* 对象创建后其状态就不能修改
* 对象的所有域都是final类型（这个并不一定啊，String就没有把所有的域都声明为final的，当然）
* 对象是正确创建的（在对象创建期间，this引用没有逃逸）

#### 4.1Final域
final类型的域是不能修改的(但是如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的)，然而在JMM中final域还有特殊的语义，比如可视性。final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无需同步。
#### 示例：使用Volatile类型来发布不可变对象

```
不可变对象
class OneValueCache{
	private final BigInteger lastNumber;
	private final BigInteger[] lastFactors;
	
	public OneValueCache(BigInteger i,BigInteger[] factors){
		lastNumber = i;
		lastFactors = Arrays.copyOf(factors, factors.length);
	}
	
	public BigInteger[] getFactors(BigInteger i){
		if(lastNumber == null || !lastNumber.equals(i)){
			return null;
		}else{
			return Arrays.copyOf(lastFactors, lastFactors.length);
		}
	}
}
```

```
使用指向不可变容器对象的volatile类型引用以缓存最新的结果
public class VolatileCacheFactorizer implements Servlet{
	private volatile OneValueCache cache new OneValueCache(null,null);
	
	public void service(ServlerRequest req,ServletResponse resp){
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = cache.getFactors(i);
		if(factors == null){
			factors = factor(i);
			cache = new OneValueCache(i, factors);
		}
	}
}
```
### 5.安全发布

```
	在没有足够同步的情况下发布对象
	public Holder holder;
	
	public void initialize(){
		holder = new Holder(42);
	}
```
由于存在可见性问题，其他线程看到的Holder对象将处于不一致的状态，即便在该对象的构造函数中已经正确的构建了不变性条件。这种不正确的发布导致其他线程看到尚未创建完成的对象。

```
	由于未被正确发布，因此这个类可能出现故障
	public class Holder {
		private int n;
		
		public Holder(int n){this.n = n;}
		
		public void assertSanity(){
			if(n != n){
				thorow new AssertionException("this false");
			}
		}
	}
```
上面的代码有两个问题：首先，除了发布对象的线程外，其他线程可以看到的Holder域是一个失效值，因此可能会看到一个空引用或者之间的旧制。第二，更糟糕的是，线程看到的Holder引用的值是最新的，但是Holder状态的值是失效的。

如果将n声明为final类型，那么Holder将不可变，从而避免出现不正确的发布问题。

#### 不可变对象与初始化安全性
由于不可变对象是一种非常重要的对象，因此JMM为不可变对象的共享提供了一种特殊的初始化安全性保障。我们已经知道，即时某个对象的引用对其他线程时可见的，也并不意味着堆栈状态对于使用该线程来说是一定可见的，为了确保对象状态能呈现出一致的视图，就必须使用同步。

另一方面，即时在发布不可变对象的引用时没有使用同步，也仍然可以安全的访问该对象。为了维持这种初始化安全性的保证，必须满足不可变性的所有需求。

**如果final类型的域所指对象是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步**

#### 安全发布的常用模式
要安全的发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：

* 在静态初始化函数中初始化一个对象引用。
* 将对象的引用保存到volatile类型的域或者AtomicReference对象中。
* 将对象的引用保存到某个正确构造对象的final类型域中。
* 将对象的引用保存到一个由锁保护的域中。

在线程安全容器内部的同步意味着，在将对象放入到某个容器中，例如Vector或SynchronizedList时，将满足上述的最后一条需求。如果线程将对象X放入一个线程安全的容器，随后线程B读取这个对象，那么可以确保B看到A设置的X状态，即便在这段读/写X的应用程序代码中没有包含显式的同步。

* 通过将一个键或值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全的将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问）。
* 通过将某个元素放入Vector CopyOnWriteArrayList CopyOnWriteArraySet synchronizedList或者SynchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。
* 通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全的发布到任何从这些队列中访问该元素的线程。

**通常，要发布一个静态构造的对象，最简单和最安全的方式就是使用静态的初始化器**
```
public static Holder holder = new Holder(42);
```
静态初始化器由JVM在类的初始化阶段执行，由于在JVM内部存在同步机制，因为通过这种方式初始化的任何对象都可以被安全的发布。

#### 事实不可变对象
如果对象在发布后不会被修改，那么对于其他在没有额外同步的情况下安全的访问这些对象的线程来说，安全发布是足够的。所有的安全发布机制都能确保，当对象的引用对所有访问该对象的线程可见时，对象发布时的状态对于所有线程也将是可见的，并且如果对象状态不会再改变，那么就足以确保任何访问都是安全的。

如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象称为"事实不可变对象"。这些对象不需要满足前面提出的不可变性的严格定义。在这些对象发布后，程序只需将它们视为不可变对象即可。通过事实不可变对象，不仅可以简化开发过程，而且还能由于减少了同步而提高性能。

**在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象**

```
public Map<String,Date> lastLogin = Collections.synchronizedMap(new HashMap<String,Date>());
```

例如：Date对象本身是可变的，但是如果Date对象的值在被放入Map后就不会改变，那么synchronizedMap中的同步机制就足以使Date值安全的发布，并且在访问这些Date值时不需要额外的同步。

#### 可变对象
对象的发布需求取决于它的可变性

* 不可变的对象可以通过任意机制发布
* 事实不可变对象必须通过安全方式发布
* 可变对象必须通过安全方式发布，并且必须是线程安全的或者由某个锁保护起来。

**在并发编程中使用和共享对象时，可以使用一些实用的策略：**

* **线程封闭：** 线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程改变。
* **只读共享：** 在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和试试不可变对象。
* **线程安全共享：** 线程安全的对象在其内部实现同步，因此多个线程可以通过对象的共有接口在进行访问而不需要进一步的同步。
* **保护对象：** 被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。


